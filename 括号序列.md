# 括号序列

## 题目描述

定义如下规则：

1. 空串是「平衡括号序列」
2. 若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」
3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。


例如，下面的字符串都是平衡括号序列：


- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`


而以下几个则不是：


- `(`，`[`，`]`，`)(`，`())`，`([()`


现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：
1. 从左到右扫描整个字符串。
2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。

配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。

## 输入格式

输入只有一行一个字符串，表示 $s$。

## 输出格式

输出一行一个字符串表示你的答案。

## 样例 #1

### 样例输入 #1

```
([()
```

### 样例输出 #1

```
()[]()
```

## 样例 #2

### 样例输入 #2

```
([)
```

### 样例输出 #2

```
()[]()
```

## 提示

### 数据规模与约定

对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。



### 处理字符串

1. 用`string s`存储，便于添加括号；使用`int pipei[101] = {false}`记录字符串中括号的匹配状态；

2. 如果检测到是右括号`']'`或者`')'`则寻找最近的==**未匹配的**==左括号`'['`、`'('`如果是相匹配的，那么两个位置都标记为`1`；

3. 输出：遍历字符串的每一位，如果是未匹配的那就直接输出匹配好的括号对，否则正常输出；

```
#include <bits/stdc++.h>
using namespace std;

void solve();

bool match(char, char);

int main() {
    solve();
    return 0;
}

void solve() {
    string s;
    //记录字符的匹配状态
    bool pipei[101] = {false};
    char c;
    //输入字符串
    while (scanf("%c", &c) != EOF) {
        s += c;
        if (c == ')' || c == ']') {
            //向前遍历，找到最近的左括号
            for (int i = s.length() - 1; i >= 0; i--) {
                //既要是左括号，又要不能匹配；
                if ((s[i] == '(' || s[i] == '[') && pipei[i] == false) {
                    //只有匹配时两者才同时变为1；
                    if (match(c, s[i])) {
                        pipei[i] = true;
                        pipei[s.length() - 1] = true;
                    }
                    //找到了停止继续查找；
                    break;
                }
            }
        }
    }
    //输出字符串
    for (int i = 0; i < s.length() - 1; i++) {
        //如果不匹配
        if (!pipei[i]) {
            switch (s[i]) {
                case '(': cout << "()";
                    break;
                case '[': cout << "[]";
                    break;
                case ')': cout << "()";
                    break;
                case ']': cout << "[]";
                    break;
                default: break;
            }
        } else {
            cout << s[i];
        }
    }
}

bool match(char a, char b) {
    if (a == '(' && b == ')') return true;
    if (a == '[' && b == ']') return true;
    if (a == ')' && b == '(') return true;
    if (a == ']' && b == '[') return true;
    return false;
}
```

