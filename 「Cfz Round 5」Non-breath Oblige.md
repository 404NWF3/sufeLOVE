# 「Cfz Round 5」Non-breath Oblige

## 题目背景

[English statement](https://www.luogu.com.cn/problem/U517656). **You must submit your code at the Chinese version of the statement.**

---

それぞれの好きを守るため  
为了保护各自的喜爱之物

君と防空壕で呼吸する  
与你在防空壕中一同呼吸

## 题目描述

给定三个整数 $n,s,t$，其中 $0 \le s,t \lt 2^n$。

你可以进行若干次操作。每次操作，你可以选择一个非负整数 $x$ 并把 $s$ 的值修改为 $x$，但有如下要求：

- 必须满足 $x<2^n$；
- 必须满足 $s\cup x=2^n-1$，其中 $\cup$ 为按位或运算；
- 你需要花费 $s\oplus x$ 的代价，其中 $\oplus$ 为按位异或运算。

你需要求出使 $s=t$ 所需代价之和的最小值。

## 输入格式

**本题有多组测试数据。**

输入的第一行包含一个正整数 $T$，表示测试数据组数。

接下来依次输入每组测试数据。对于每组测试数据，输入共一行，包含三个整数 $n,s,t$。

## 输出格式

对于每组测试数据，输出一行一个整数，表示使 $s=t$ 所需代价之和的最小值。

## 样例 #1

### 样例输入 #1

```
3
2 1 2
3 1 1
5 1 4
```

### 样例输出 #1

```
3
0
57
```

## 提示

#### 「样例解释 #1」

对于第 $1$ 组测试数据，由于 $1 \cup 2 = 3$，所以可以直接将 $s$ 的值从 $1$ 修改为 $2$，此时的代价为 $1 \oplus 2$，即 $3$。可以证明使 $s=t$ 所需代价之和的最小值为 $3$。

对于第 $2$ 组测试数据，不需要进行操作即可满足 $s=t$。

#### 「数据范围」

对于所有测试数据，保证：

- $1 \le T \le 100$；
- $1 \le n \le 30$；
- $0 \le s,t \lt 2^n$。

**本题采用捆绑测试。**

- Subtask 0（12 points）：$s=t$。
- Subtask 1（15 points）：$n=1$。
- Subtask 2（20 points）：$s+t=2^n-1$。
- Subtask 3（10 points）：$t=2^n-1$。
- Subtask 4（18 points）：$t=0$。
- Subtask 5（25 points）：无特殊限制。



位或运算（OR）和异或运算（XOR）是两种常见的位操作，它们都作用于二进制数的每一位，进行逐位的逻辑运算。下面是对它们的详细解释：



### 1. 位或运算（OR，|）

位或运算是对两个二进制数的每一位进行“或”运算。规则是：当两个对应的二进制位中至少有一个是 1 时，结果位为 1，否则为 0。

#### 运算规则：

- 1 | 1 = 1
- 1 | 0 = 1
- 0 | 1 = 1
- 0 | 0 = 0

#### 例子：

假设有两个二进制数：`A = 1010` 和 `B = 1100`，进行位或运算：

```
  A = 1010
  B = 1100
  --------------
A | B = 1110
```

**解释：**

- 第一位：1 | 1 = 1
- 第二位：0 | 1 = 1
- 第三位：1 | 0 = 1
- 第四位：0 | 0 = 0

因此，结果是 `1110`。



### 2. 异或运算（XOR，^）

异或运算是对两个二进制数的每一位进行“异或”运算。规则是：当两个对应的二进制位相同时，结果为 0；当两个对应的二进制位不同时，结果为 1。

#### 运算规则：

- 1 ^ 1 = 0
- 1 ^ 0 = 1
- 0 ^ 1 = 1
- 0 ^ 0 = 0

#### 例子：

假设有两个二进制数：`A = 1010` 和 `B = 1100`，进行异或运算：

```
  A = 1010
  B = 1100
  --------------
A ^ B = 0110
```

**解释：**

- 第一位：1 ^ 1 = 0
- 第二位：0 ^ 1 = 1
- 第三位：1 ^ 0 = 1
- 第四位：0 ^ 0 = 0

因此，结果是 `0110`。

### 总结：

- 位或运算（OR）：如果对应位中至少有一个是 1，结果就是 1。
- 异或运算（XOR）：如果对应位不同，结果就是 1；如果相同，结果就是 0。



### 于是：

我们需要将整数 `s` 转换为 `t`，通过一系列操作，每次操作可以将 `s` 修改为一个新的整数 `x`，满足以下条件：

1. `x < 2^n`
2. `s | x = 2^n - 1` （按位或运算）
3. 操作的代价为 `s ^ x` （按位异或运算）

目标是使得最终 `s = t`，并且总代价最小。

### 关键观察

1. **直接转换**：
   - 如果 `s == t`，无需任何操作，总代价为 `0`。
   - 如果 `s | t = 2^n - 1`，则可以直接将 `s` 修改为 `t`，总代价为 `s ^ t`。
2. **间接转换**：
   - 如果 `s | t ≠ 2^n - 1`，需要通过中间状态来达到目标 `t`。
   - 一个有效的策略是先将 `s` 修改为 `mask = 2^n - 1`，然后再将 `mask` 修改为 `t`。总代价为 `(s ^ mask) + (mask ^ t)`。
3. **最优性**：
   - 通过上述分析，可以证明在 `s | t ≠ mask` 的情况下，通过两步操作达到目标 `t` 是最优的。



```
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n;
        ull s, t;
        cin >> n >> s >> t;

        ull mask = (1ULL << n) - 1;

        if (s == t) {
            cout << "0\n";
        } else if ((s | t) == mask) {
            cout << (s ^ t) << "\n";
        } else {
            ull cost = (s ^ mask) + (mask ^ t);
            cout << cost << "\n";
        }
    }

    return 0;
}
```